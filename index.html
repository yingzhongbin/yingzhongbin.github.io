<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>应忠彬的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="应忠彬的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="应忠彬的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="应忠彬的博客">
  
    <link rel="alternate" href="/atom.xml" title="应忠彬的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">应忠彬的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CSS笔记-长期更新" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/01/CSS笔记-长期更新/" class="article-date">
  <time datetime="2018-10-01T12:29:49.000Z" itemprop="datePublished">2018-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/01/CSS笔记-长期更新/">CSS笔记(长期更新)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="CSS-white-space-属性"><a href="#CSS-white-space-属性" class="headerlink" title="CSS white-space 属性"></a>CSS white-space 属性</h4><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>white-space</td>
<td>属性设置如何处理元素内的空白</td>
</tr>
<tr>
<td>normal</td>
<td>默认。空白会被浏览器忽略。</td>
</tr>
<tr>
<td>pre</td>
<td>空白会被浏览器保留。其行为方式类似 HTML 中的 <code>&lt;pre&gt;</code> 标签。</td>
</tr>
<tr>
<td>nowrap</td>
<td>文本不会换行，文本会在在同一行上继续，直到遇到 <code>&lt;br&gt;</code>标签为止。</td>
</tr>
<tr>
<td>pre-wrap</td>
<td>保留空白符序列，但是正常地进行换行。</td>
</tr>
<tr>
<td>pre-line</td>
<td>合并空白符序列，但是保留换行符。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 white-space 属性的值。</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/01/CSS笔记-长期更新/" data-id="cjmqbc2qm00023hf4xn3i89we" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释/" class="article-date">
  <time datetime="2018-09-28T12:17:42.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释/">flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="文字超过部分显示为省略号的css写法很简单"><a href="#文字超过部分显示为省略号的css写法很简单" class="headerlink" title="文字超过部分显示为省略号的css写法很简单"></a>文字超过部分显示为省略号的css写法很简单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	text-overflow: ellipsis;</span><br><span class="line">  	overflow: hidden;</span><br><span class="line"> 	white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是：可以不加宽度<code>width:xxx;</code>，也不用加min-width。这时， 文字超过部分会乖乖地显示为省略号。</p>
<p>在flex布局下，当flex-grow设置为1（即自由伸缩）的情况下，是不需要设置宽度，内容就会自动生长。没有宽度设定，在flex布局下flex-grow部分中，上述三行代码无法生效。它就像脱缰的野马一样，说：“你没有给我设定宽度啊，我grow了，不需要显示为省略号，略略略~~~。”</p>
<h6 id="那如何解决呢？"><a href="#那如何解决呢？" class="headerlink" title="那如何解决呢？"></a>那如何解决呢？</h6><p>只要设定一下<code>width:xxx;</code>，甚至可以设置为<code>width:0px;</code>。设置min-width不生效。<br>总之，flew-grow控制伸缩。而上述代码加宽度管超出省略。而flex-grow的优先级高于width，仍然可以伸缩。宽度设置只是做个样子，告诉内容你给我丫的显示为省略号！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/28/flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释/" data-id="cjmqbc2rj00083hf4p4pmjlly" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/08/http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified/" class="article-date">
  <time datetime="2018-09-08T07:54:04.000Z" itemprop="datePublished">2018-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified/">http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="笔记摘要"><a href="#笔记摘要" class="headerlink" title="笔记摘要"></a>笔记摘要</h3><p>cookie session cache-control都是响应头</p>
<h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><p>GET /xxx HTTP/1.1<br>Host:xxx.com</p>
<h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>HTTP/1.1 200 ok<br>Content-Type:text/html;charset=utf8<br>Content-Length:100b  </p>
<h6 id="js发送请求代码"><a href="#js发送请求代码" class="headerlink" title="js发送请求代码"></a>js发送请求代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var request = new XMLHttpRequest()</span><br><span class="line">request.open(“POST”,’/xxx’)</span><br><span class="line">request.onreadystatechange = function()&#123;</span><br><span class="line">	if(request.readyState === 4 &amp;&amp; request.status ===200)&#123;</span><br><span class="line">		响应成功</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 发送请求</span><br><span class="line"> request.send(“a=1&amp;b=2”)</span><br></pre></td></tr></table></figure>
<p>cookie就是入门票  每来一次都要出示一次</p>
<h3 id="Cookie特点"><a href="#Cookie特点" class="headerlink" title="Cookie特点"></a>Cookie特点</h3><p>1.服务器通过Set-Cookie 响应头设置Cookie<br>2.浏览器得到Cookie之后，每次请求都要带上Cookie<br>3.服务器读取Cookie就知道登录用户的信息  </p>
<h6 id="Cookie相关问题"><a href="#Cookie相关问题" class="headerlink" title="Cookie相关问题"></a>Cookie相关问题</h6><p>1.我在Chrome登录了得到Cookie，用Safar访问，Safari会带上Cookie吗<br>NO  </p>
<p>2.Cookie存在哪？<br>存在系统的一个文件里 </p>
<p>3.Cookie能作假吗？<br>可以    </p>
<p>4.Cookie有有效期吗？<br>默认有效期20分钟左右,后端可以强制设置有效期  </p>
<h4 id="登录注册的Cookie设定过程"><a href="#登录注册的Cookie设定过程" class="headerlink" title="登录注册的Cookie设定过程"></a>登录注册的Cookie设定过程</h4><table>
<thead>
<tr>
<th>服务器</th>
<th>过程</th>
<th>用户</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>开始注册</td>
</tr>
<tr>
<td></td>
<td>&lt;==发送POST请求，数据为email,passpword,password_confirm</td>
<td></td>
</tr>
<tr>
<td>将数据email，passpword写入数据库</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>注册成功 ==&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>开始登录</td>
</tr>
<tr>
<td></td>
<td>&lt;==发送POST请求，数据为email,passpword</td>
<td></td>
</tr>
<tr>
<td>验证成功</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>SetCookie 数据为email ==&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>打开首页</td>
</tr>
<tr>
<td></td>
<td>&lt;==发送GET请求，会带上Cookie里的数据email</td>
<td></td>
</tr>
<tr>
<td>读取Cookie里的数据email，找到数据库里的用户信息，返回index.html,并将index.html里需要的用户信息替换掉</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>使用Cookie过程<br>1.Set-Cookie<br>2.每次请求相同域名时带上Cookie  </p>
<p>用途：<br>登录成功</p>
<p>电脑上设置了Cookie，每次访问首页时，会带上Cookie发送请求。<br>服务器读取Cookie。如果有信息，去数据库寻找用户信息返回。</p>
<p>Cookie有一个缺点，可以被篡改。所以就引入了session</p>
<p>什么是Session?<br>服务器通过Cookie给用户一个sessionId，sessionId对应服务器里的一小块内存。每次用户访问服务器时，服务器就通过sessionId读取对应的Session，得到用户的隐私信息。</p>
<p>Cookie  </p>
<ol>
<li>服务器通过 Set-Cookie 头给客户端一串字符串  </li>
<li>客户端每次访问相同域名的网页时，必须带上这段字符串  </li>
<li>客户端要在一段时间内保存这个Cookie  </li>
<li>Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间  </li>
<li>大小大概在 4kb 以内 </li>
</ol>
<p>Session（不翻译）  </p>
<ol>
<li>将 SessionID（随机数）通过 Cookie 发给客户端  </li>
<li>客户端访问服务器时，服务器读取 SessionID  </li>
<li>服务器有一块内存（哈希表）保存了所有 session  </li>
<li>通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email  </li>
<li>这块内存（哈希表）就是服务器上的所有 session </li>
</ol>
<p>LocalStorage    </p>
<ol>
<li>LocalStorage 跟 HTTP 无关  </li>
<li>HTTP 不会带上 LocalStorage 的值  </li>
<li>只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格）  </li>
<li>每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）  </li>
<li>常用场景：记录有没有提示过用户（没有用的信息，不能记录密码）  </li>
<li>LocalStorage 永久有效，除非用户清理缓存  </li>
</ol>
<p>SessionStorage（会话存储）  </p>
<ol>
<li>1、2、3、4 同上    </li>
<li>5：SessionStorage 在用户关闭页面（会话结束）后就失效。</li>
</ol>
<p>localStorage是持久化存储，用户不清空，不会过期<br>localStorage是html5里的API</p>
<h6 id="localStorage-API"><a href="#localStorage-API" class="headerlink" title="localStorage API"></a>localStorage API</h6><p>localStorage.setItem(key,value)<br>localStorage.getItem(key)<br>localStorage.clear()  </p>
<h6 id="sessionStorage-API"><a href="#sessionStorage-API" class="headerlink" title="sessionStorage API"></a>sessionStorage API</h6><p>sessionStorage.setItem(key,value)<br>sessionStorage.getItem(key)<br>sessionStorage.removeItem(key)  </p>
<h6 id="Cookie-Session什么关系？"><a href="#Cookie-Session什么关系？" class="headerlink" title="Cookie Session什么关系？"></a>Cookie Session什么关系？</h6><p>Session是基于Cookie实现的<br>Cookie localStorage有什么区别？<br>Cookie会被发送给服务器，localStorage不会。<br>localStorage SessionStorage什么区别  </p>
<p>session 也可以通过查询参数和localStorage来设置</p>
<p>前端永远不要读、写Cookie</p>
<h6 id="缓存控制-Cache-Control，设置后用户可以直接从缓存中读取文件，不发起请求"><a href="#缓存控制-Cache-Control，设置后用户可以直接从缓存中读取文件，不发起请求" class="headerlink" title="缓存控制 Cache-Control，设置后用户可以直接从缓存中读取文件，不发起请求"></a>缓存控制 Cache-Control，设置后用户可以直接从缓存中读取文件，<em>不发起请求</em></h6><table>
<thead>
<tr>
<th>服务器</th>
<th>过程</th>
<th>用户</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>&lt;==发送请求，请求文件main.js</td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回main.js文件 以及响应头max-age:30 ==&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;==同样的url请求（没有发送请求）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>==&gt;从内存里读取上一次的main.js</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;==过了30秒，发送请求，请求文件main.js</td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回main.js文件 以及响应头max-age:30 ==&gt;</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>response.setHeader(“Cache-Control”,”max-age=30”)//30秒内不需要再次请求，内容直接从缓存里读取</code></p>
<p>首页不允许设置缓存。<br>只有相同的url才会利用上次的缓存，所以，如果文件更新了，设置一个查询参数就可以了。<br>href=“default.css?v=2”  </p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>从前使用 Expires<br>现在使用 Cache-Control<br><code>response.setHeader(“Expires”,”未来的格林威治时间点”)</code><br>它是与用户的本地时间进行对比的，如果用户本地时间错乱，那就有问题了。  </p>
<h3 id="ETag-直接不下载（有请求）"><a href="#ETag-直接不下载（有请求）" class="headerlink" title="ETag  直接不下载（有请求）"></a>ETag  直接不下载（有请求）</h3><p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。<br>http  304 Not Modified</p>
<p>node.js代码<br><code>`
let fileMd5 = md5(file)
response.setHeader(“ETag”,fileMd5)
if(request.headers[‘if-none-match’] === fileMd5){
    //没有响应体
    response.statusCode = 304
}else{
    response.write(file)
}
response.end()</code></p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</p>
<h6 id="Last-Modified格式类似这样："><a href="#Last-Modified格式类似这样：" class="headerlink" title="Last-Modified格式类似这样："></a>Last-Modified格式类似这样：</h6><p>Last-Modified : Fri , 12 May 2006 18:53:33 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过：<br>If-Modified-Since : Fri , 12 May 2006 18:53:33 GMT<br>如果服务器端的资源没有变化，则自动返回 HTTP 304（Not Changed.）状态码，内容为空，这样就节省了传输数据量。  </p>
<p>从资源更新原理来看Last-Modified和Etag基本是类似的，那为什么http协议中要搞2个标识呢？<br>Last-Modified存在的问题：<br>1、在集群服务器上各个服务器上的文件时间可能不同。<br>2、如果用旧文件覆盖新文件，因为时间更前，浏览器不会请求这个更旧的文件。<br>3、时间精度为s级，对文件修改精度有严格要求的场景不能满足  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/08/http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified/" data-id="cjmqbc2sb000d3hf471fruykv" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-路由" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/11/路由/" class="article-date">
  <time datetime="2018-08-11T08:23:59.000Z" itemprop="datePublished">2018-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/11/路由/">路由</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1.什么是路由"></a>1.什么是路由</h1><pre><code>简单举例说明，假如我们有一台提供 Web 服务的服务器的网络地址是：10.0.0.1，而该 Web 服务又提供了三个可供用户访问的页面，其页面 URI 分别是：
http://10.0.0.1/  
http://10.0.0.1/about  
http://10.0.0.1/concat  
那么其路径就分别是 /，/about，/concat。  
当用户使用 http://10.0.0.1/about 来访问该页面时，Web 服务会接收到这个请求，然后会解析 URL 中的路径 /about。在 Web 服务的程序中，该路径对应着相应的处理逻辑，程序会把请求交给路径所对应的处理逻辑，这样就完成了一次「路由分发」，这个分发就是通过「路由」来完成的。  
以前路由都是后台做的，通过用户请求的url导航到具体的html页面，前端路由就是通过配置js文件，把这个工作拿到前端来做。  
简单的说，路由是根据不同的 url 地址展示不同的内容或页面。
</code></pre><p>#2.    路由的作用<br>    路由的作用就是通过对用户访问的路径进行判断，将其发送到对应的处理请求逻辑上。</p>
<p>#3.    Vue 如何实现路由及其相关代码<br>     Vue官网已经有关于路由（Router）的详细代码介绍。我将根据官网的代码介绍其实现原理。<br>首先，引入vue.js和vue的vue-router文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Hello App!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;router-link to=&quot;/tab1&quot;&gt;Go to tab1&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/tab2&quot;&gt;Go to tab2&lt;/router-link&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const tab1 = &#123; template: &apos;&lt;div&gt;content 1&lt;/div&gt;&apos; &#125;</span><br><span class="line">const tab2 = &#123; template: &apos;&lt;div&gt;content 2&lt;/div&gt;&apos; &#125;</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">    &#123; path: &apos;/tab1&apos;, component: tab1 &#125;,</span><br><span class="line">    &#123; path: &apos;/tab2&apos;, component: tab2 &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes // (缩写) 相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<pre><code>总结：在HTML代码中，Vue Router 使用router-link 标签来进行路由导航。通过传入 `to` 属性指定链接。&lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签。路由匹配到的组件将渲染在router-view标签中。
在JS代码中，需要做如下几件事情：
1.定义 (路由) 组件
2.定义路由（将路由组件传入到路由中）
3. 创建 router 实例
4. 创建和挂载根实例
</code></pre><h1 id="4-Vue-Router的优缺点"><a href="#4-Vue-Router的优缺点" class="headerlink" title="4.Vue Router的优缺点"></a>4.Vue Router的优缺点</h1><pre><code>Vue Router并不涉及后端。在前端进行路由分发时，需要后端对相应的路径进行放宽处理。  
比如：http://127.0.0.1:8081/tab0中，tab0 只是一个标记，在分享时，服务器需要放松对该路径的响应，直接返回index.html。但Vue Router并不需要后端进行任何处理，这为优点。
举例：Vue Router的链接响应处理为&lt;a href=&quot;#/tab1&quot; class=&quot;router-link-exact-active router-link-active&quot;&gt;Go to tab1&lt;/a&gt;。实际上是根据hash的不同调动页面状态。如果页面中有其他锚点的话，原有页面状态就很容易丢失了。也即为缺点。如果有其他需求需要规避这个缺点，可以通过修改pathname来记录页面状态。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/11/路由/" data-id="cjmqbc2tg000l3hf4otc06jdd" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue的三种通信方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/08/Vue的三种通信方法/" class="article-date">
  <time datetime="2018-08-08T09:18:56.000Z" itemprop="datePublished">2018-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/08/Vue的三种通信方法/">Vue的三种通信方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h1><p>vue的父子通信是有层级关系的，所以互相通信的方式也不一样。总结起来就是：prop向下传递，事件向上传递。父级组件通过prop向子级组件发送数据，子级组件通过事件给父级组件发送消息。下面贴出代码。</p>
<p>子级组件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">    props:[&quot;visible&quot;],</span><br><span class="line">    template:`</span><br><span class="line">        &lt;div v-show=&quot;visible&quot;&gt;</span><br><span class="line">            我是子级组件</span><br><span class="line">            &lt;button @click=&quot;$emit(&apos;close&apos;)&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>父级组件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        visible:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>HTML代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;visible=true&quot;&gt;打开&lt;/button&gt;</span><br><span class="line">  &lt;child @close=&quot;visible=false&quot; :visible=&quot;visible&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>父级组件通过props向子级组件传递visible变量，从而控制子级组件child是否显示。子级组件通过向父级组件发送事件<code>$emit(&#39;close’)</code>，通知父级组件修改visible变量，从而控制自己隐藏。</p>
<h1 id="爷孙通信"><a href="#爷孙通信" class="headerlink" title="爷孙通信"></a>爷孙通信</h1><p>有了父子组件通信的基础，爷孙组件通信就易于理解了。代码如下。</p>
<p>孙级组件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&quot;grandchild&quot;,&#123;</span><br><span class="line">    template:`</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是孙级组件</span><br><span class="line">            &lt;button @click=&quot;$emit(&apos;close&apos;)&quot;&gt;关闭&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>父级组件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">    props:[&quot;visible&quot;],</span><br><span class="line">    template:`</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是父级组件</span><br><span class="line">            &lt;grandchild v-show=&quot;visible&quot; @close=&quot;$emit(&apos;close&apos;)&quot;&gt;&lt;/grandchild&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>爷级组件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &apos;爷级组件&apos;,</span><br><span class="line">        visible:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>HTML代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;visible=true&quot;&gt;打开&lt;/button&gt;</span><br><span class="line">  &lt;child :visible=&quot;visible&quot; @close=&quot;visible=false&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>总结起来还是那句话：prop向下传递，事件向上传递。但爷级组件无法直接控制孙级组件。只能通过<code>props:[&quot;visible&quot;]</code>向子级组件发送数据，子级组件再将数据传给孙级组件，通过<code>v-show=&quot;visible&quot;</code>实现控制孙级组件的目的。孙级组件通过事件<code>@click=&quot;$emit(&#39;close&#39;)&quot;</code>给父级组件发送消息，父级组件再通过事件<code>@click=&quot;$emit(&#39;close&#39;)&quot;</code>给爷级组件发送消息，爷级组件响应事件<code>@close=&quot;visible=false”</code>，从而修改数据。</p>
<h1 id="兄弟通信"><a href="#兄弟通信" class="headerlink" title="兄弟通信"></a>兄弟通信</h1><p>兄弟通信的原理与上所述不同。是通过事件发布、订阅模式来进行通信的。</p>
<p>首先需要一个Vue实例<br><code>var bus = new Vue()</code>作为兄弟组件的通信渠道。</p>
<p>兄组件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&quot;brotherelder&quot;,&#123;</span><br><span class="line">    template:`</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是大哥</span><br><span class="line">            &lt;button @click=&quot;callYoung&quot;&gt;通知二弟&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        callYoung()&#123;</span><br><span class="line">            alert(&quot;通知弟弟&quot;);</span><br><span class="line">            bus.$emit(&quot;callYoung&quot;,&quot;弟，妈喊你吃饭了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        bus.$on(&quot;callElder&quot;,()=&gt;&#123;</span><br><span class="line">            alert(&quot;哥知道了，我去吃饭了&quot;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>弟组件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&quot;brotheryounger&quot;,&#123;</span><br><span class="line">    template:`</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是二弟</span><br><span class="line">            &lt;button @click=&quot;callElder&quot;&gt;通知哥哥&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    `,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        callElder()&#123;</span><br><span class="line">            alert(&quot;通知哥哥&quot;);</span><br><span class="line">            bus.$emit(&quot;callElder&quot;,&quot;哥，妈喊你吃饭了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        bus.$on(&quot;callYoung&quot;,()=&gt;&#123;</span><br><span class="line">            alert(&quot;知道了，我去吃饭了&quot;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>再实例化挂载点，就可以实现通信了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>总结：兄弟组件通过vue的实例bus来发布事件<code>·bus.$emit(&quot;callElder&quot;,&quot;哥，妈喊你吃饭了”)</code>、再通过订阅事件<code>bus.$on(&quot;callYoung&quot;,()=&gt;{alert(&quot;知道了，我去吃饭了&quot;)})</code>，来实现兄弟组件的通信。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/08/Vue的三种通信方法/" data-id="cjmqbc2r200053hf4gmtqq8un" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-icon的各种做法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/09/icon的各种做法/" class="article-date">
  <time datetime="2018-06-09T02:34:21.000Z" itemprop="datePublished">2018-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/09/icon的各种做法/">icon的各种做法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>img 法</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;xxx.png&quot; alt=&quot;微博&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>background 法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.icon.weibo&#123;</span><br><span class="line">   	background-image:url(./weibo.png);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>background 合一法</p>
<p> 什么是<a href="https://baike.baidu.com/item/CSS%20Sprite" target="_blank" rel="noopener">css sprites 雪碧图</a>?</p>
<p> 使用<a href="http://css.spritegen.com/" target="_blank" rel="noopener">css sprites generator 雪碧图生成器</a></p>
<p> 复制粘贴YOUR CSS，YOUR HTML里的代码，并下载对应的雪碧图，即可使用雪碧图。</p>
</li>
<li><p>unicode引用</p>
<p>点击<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴矢量图标库</a>，选择对应的图标放入仓库。</p>
<blockquote>
<p>unicode是字体在网页端最原始的应用方式，特点是：</p>
<ul>
<li>兼容性最好，支持ie6+，及所有现代浏览器。</li>
<li>支持按字体的方式去动态调整图标大小，颜色等等。</li>
<li>但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。</li>
</ul>
</blockquote>
<blockquote>
<p>unicode使用步骤如下：</p>
<ul>
<li>第一步：拷贝项目下面生成的font-face</li>
<li>第二步：定义使用iconfont的样式</li>
<li>第三步：挑选相应图标并获取字体编码，应用于页面<br><code>&lt;i class=&quot;iconfont&quot;&gt;&amp;#x33;&lt;/i&gt;</code></li>
</ul>
</blockquote>
</li>
<li><p>font-class引用 </p>
<p>font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题。与unicode使用方式相比，具有如下特点：</p>
<ul>
<li>兼容性良好，支持ie8+，及所有现代浏览器。</li>
<li>相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。</li>
<li>因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。</li>
<li>不过因为本质上还是使用的字体，所以多色图标还是不支持的。<blockquote>
<p>使用步骤如下：</p>
<ul>
<li>第一步：拷贝项目下面生成的fontclass代码：<br><code>//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css</code></li>
<li>第二步：挑选相应图标并获取类名，应用于页面：<br><code>&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</code></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>SVG 法（symbol引用）</p>
<blockquote>
<p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个svg的集合，与上面两种相比具有如下特点：</p>
</blockquote>
<blockquote>
<ul>
<li>支持多色图标了，不再受单色限制。</li>
<li>通过一些技巧，支持像字体那样，通过font-size,color来调整样式。</li>
<li>兼容性较差，支持 ie9+,及现代浏览器。</li>
<li>浏览器渲染svg的性能一般，还不如png。<br>使用步骤如下：</li>
</ul>
</blockquote>
<blockquote>
<p>第一步：拷贝项目下面生成的symbol代码：<br> <code>//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js</code></p>
</blockquote>
<blockquote>
<p>第二步：加入通用css代码（引入一次就行）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .icon &#123;</span><br><span class="line">       width: 1em; height: 1em;</span><br><span class="line">       vertical-align: -0.15em;</span><br><span class="line">       fill: currentColor;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p> 第三步：挑选相应图标并获取类名，应用于页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>新手慎用：「CSS 就是干」法<br>使用css手绘icon，可见<a href="http://cssicon.space/#/" target="_blank" rel="noopener">达人网站</a></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/09/icon的各种做法/" data-id="cjmqbc2sn000e3hf435dx05ks" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="js-登录注册与Cookie" class="article article-type-js" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/25/登录注册与Cookie/" class="article-date">
  <time datetime="2018-05-25T02:51:42.000Z" itemprop="datePublished">2018-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/25/登录注册与Cookie/">登录注册与Cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS-登录注册与Cookie"><a href="#JS-登录注册与Cookie" class="headerlink" title="JS 登录注册与Cookie"></a>JS 登录注册与Cookie</h1><p>前端往往对后端的操作感到迷惑和神秘。虽然以前编辑过耍票性质的网站，对后端有一定了解，但对HTTP和状态码等内容还是不熟悉。但那段经历还是让我能更好的理解后端操作。</p>
<p>接下来，我将详细讲述JS的登录注册与Cookie内容。<br>登录注册容易理解，Cookie有什么用呢？Cookie能始终为浏览者提供稳定的信息，Cookie存储了数据，不需要持续与服务器交互GET相同的信息。</p>
<p>首先，需要验证是否已有Cookie存在，若无，则调到登录/注册界面。第三步会发送Cookie。</p>
<p>第一步：注册页面发送POST请求<br>响应成功，打印响应内容，反之，提示邮箱格式错误</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.post(&apos;/sign_up&apos;, hash)</span><br><span class="line">    .then((response) =&gt; &#123;</span><br><span class="line">        console.log(response)</span><br><span class="line">    &#125;, (request) =&gt; &#123;</span><br><span class="line">        let &#123; errors &#125; = request.responseJSON</span><br><span class="line">        if (errors.email &amp;&amp; errors.email === &apos;invalid&apos;) &#123;</span><br><span class="line">            $form.find(&apos;[name=&quot;email&quot;]&apos;).siblings(&apos;.error&apos;)</span><br><span class="line">                .text(&apos;邮箱格式错误&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>server服务器响应</p>
<ul>
<li>1.将得到信息拼接到一起，readBody()</li>
<li>2.将得到的信息拆分到hash中。检查，如果邮箱无@符号，返回错误信息：”email”: “invalid”。</li>
<li>3.如果信息无误，写入数据库中</li>
</ul>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">if(path === &apos;/sign_up&apos; &amp;&amp; method === &apos;POST&apos;)&#123;</span><br><span class="line">    readBody(request).then((body)=&gt;&#123;</span><br><span class="line">      let strings = body.split(&apos;&amp;&apos;) // [&apos;email=1&apos;, &apos;password=2&apos;, &apos;password_confirmation=3&apos;]</span><br><span class="line">      let hash = &#123;&#125;</span><br><span class="line">      strings.forEach((string)=&gt;&#123;</span><br><span class="line">        // string == &apos;email=1&apos;</span><br><span class="line">        let parts = string.split(&apos;=&apos;) // [&apos;email&apos;, &apos;1&apos;]</span><br><span class="line">        let key = parts[0]</span><br><span class="line">        let value = parts[1]</span><br><span class="line">        hash[key] = decodeURIComponent(value) // hash[&apos;email&apos;] = &apos;1&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">      let &#123;email, password, password_confirmation&#125; = hash</span><br><span class="line">      if(email.indexOf(&apos;@&apos;) === -1)&#123;</span><br><span class="line">        response.statusCode = 400</span><br><span class="line">        response.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;)</span><br><span class="line">        response.write(`&#123;</span><br><span class="line">          &quot;errors&quot;: &#123;</span><br><span class="line">            &quot;email&quot;: &quot;invalid&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;`)</span><br><span class="line">      &#125;else if(password !== password_confirmation)&#123;</span><br><span class="line">        response.statusCode = 400</span><br><span class="line">        response.write(&apos;password not match&apos;)</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        var users = fs.readFileSync(&apos;./db/users&apos;, &apos;utf8&apos;)</span><br><span class="line">        try&#123;</span><br><span class="line">          users = JSON.parse(users) // []</span><br><span class="line">        &#125;catch(exception)&#123;</span><br><span class="line">          users = []</span><br><span class="line">        &#125;</span><br><span class="line">        let inUse = false</span><br><span class="line">        for(let i=0; i&lt;users.length; i++)&#123;</span><br><span class="line">          let user = users[i]</span><br><span class="line">          if(user.email === email)&#123;</span><br><span class="line">            inUse = true</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(inUse)&#123;</span><br><span class="line">          response.statusCode = 400</span><br><span class="line">          response.write(&apos;email in use&apos;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          users.push(&#123;email: email, password: password&#125;)</span><br><span class="line">          var usersString = JSON.stringify(users)</span><br><span class="line">          fs.writeFileSync(&apos;./db/users&apos;, usersString)</span><br><span class="line">          response.statusCode = 200</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      response.end()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  //因为服务器发送内容是分段的，所以，需要将接收到的信息拼接到一起</span><br><span class="line">  function readBody(request)&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">    let body = []</span><br><span class="line">    request.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">      body.push(chunk);</span><br><span class="line">    &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      body = Buffer.concat(body).toString();</span><br><span class="line">      resolve(body)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：登录发送POST请求<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.post(&apos;/sign_in&apos;, hash)  </span><br><span class="line">  .then((response)=&gt;&#123;</span><br><span class="line">    window.location.href = &apos;/&apos;</span><br><span class="line">  &#125;, (request)=&gt;&#123;</span><br><span class="line">    alert(&apos;邮箱与密码不匹配&apos;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>服务器校对用户名和密码后，如果正确，使用Cookie发送用户信息<code>response.setHeader(&#39;Set-Cookie&#39;, `sign_in_email=${email}</code><br>使网页得到用户信息，并显示出来<br>完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if (path === &apos;/sign_in&apos; &amp;&amp; method === &apos;POST&apos;) &#123;</span><br><span class="line">    readBody(request).then((body) =&gt; &#123;</span><br><span class="line">        let strings = body.split(&apos;&amp;&apos;) // [&apos;email=1&apos;, &apos;password=2&apos;, &apos;password_confirmation=3&apos;]</span><br><span class="line">        let hash = &#123;&#125;</span><br><span class="line">        strings.forEach((string) =&gt; &#123;</span><br><span class="line">            // string == &apos;email=1&apos;</span><br><span class="line">            let parts = string.split(&apos;=&apos;) // [&apos;email&apos;, &apos;1&apos;]</span><br><span class="line">            let key = parts[0]</span><br><span class="line">            let value = parts[1]</span><br><span class="line">            hash[key] = decodeURIComponent(value) // hash[&apos;email&apos;] = &apos;1&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        let &#123; email, password &#125; = hash</span><br><span class="line">        var users = fs.readFileSync(&apos;./db/users&apos;, &apos;utf8&apos;)</span><br><span class="line">        try &#123;</span><br><span class="line">            users = JSON.parse(users) // []</span><br><span class="line">        &#125; catch (exception) &#123;</span><br><span class="line">            users = []</span><br><span class="line">        &#125;</span><br><span class="line">        let found</span><br><span class="line">        for (let i = 0; i &lt; users.length; i++) &#123;</span><br><span class="line">            if (users[i].email === email &amp;&amp; users[i].password === password) &#123;</span><br><span class="line">                found = true</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (found) &#123;</span><br><span class="line">            response.setHeader(&apos;Set-Cookie&apos;, `sign_in_email=$&#123;email&#125;`)</span><br><span class="line">            response.statusCode = 200</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response.statusCode = 401</span><br><span class="line">        &#125;</span><br><span class="line">        response.end()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上即为登录注册及Cookie的基本使用细节。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/25/登录注册与Cookie/" data-id="cjmqbc2tf000k3hf4c63lkcx8" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-异步与回调" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/24/异步与回调/" class="article-date">
  <time datetime="2018-05-24T01:20:03.000Z" itemprop="datePublished">2018-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/24/异步与回调/">异步与回调</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript是单线程的。异步，如果理解为多线程，同时在跑多个程序的话，那么，就跑偏了。</p>
<p>那如何理解异步呢。</p>
<p>比如有三个function:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">function f2()&#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">function f3()&#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br></pre></td></tr></table></figure></p>
<p>三个函数会按顺序依次打印：1，2，3，就像依次走过一列火车上的三节车厢</p>
<p>那什么是异步呢？</p>
<p>同步：一定要等任务执行完了，得到结果，才执行下一个任务。</p>
<p>异步：不等任务执行完，直接执行下一个任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function taskAsync = function()&#123;</span><br><span class="line">  var result = setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;异步任务的结果&apos;)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = taskAsync() // result 不是异步任务的结果，而是一个 timer id</span><br><span class="line">otherTask()              // 立即执行其他任务，不等异步任务结束</span><br></pre></td></tr></table></figure></p>
<p>我们拿到的 result 不是异步执行的结果，而是一个 timer id，那么要怎么拿到异步任务的结果呢？</p>
<p>用回调。</p>
<p>改下代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function taskAsync = function(callback)&#123;</span><br><span class="line">  var result = setTimeout(function()&#123;</span><br><span class="line">    callback(&apos;异步任务的结果&apos;)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskAsync(function callback(result)&#123;</span><br><span class="line">  console.log(result) // 三秒钟后，这个 callback 函数会被执行</span><br><span class="line">&#125;)</span><br><span class="line">otherTask()              // 立即执行其他任务，不等异步任务结束</span><br></pre></td></tr></table></figure></p>
<p>所以“回调”经常用于获取“异步任务”的结果。</p>
<p>而如何在等待异步任务结束后立即执行一个函数呢，只要将回调函数，放在异步任务结束处即可，比如放在clearInterval()后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function writeCode(options,fn) &#123;</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      window.clearInterval(timerId)</span><br><span class="line">       fn();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异步，可以理解为一辆火车，确定的函数放在前头，而异步或按时间或按进程放在该放在的第n节车厢执行。但那节车厢只能放置异步，不能放置其他函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/24/异步与回调/" data-id="cjmqbc2te000j3hf4u5x0i5sc" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/17/AJAX/" class="article-date">
  <time datetime="2018-05-17T02:28:40.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="34-高级：AJAX-是什么鬼"><a href="#34-高级：AJAX-是什么鬼" class="headerlink" title="34 高级：AJAX 是什么鬼"></a>34 高级：AJAX 是什么鬼</h1><h2 id="如何发请求？"><a href="#如何发请求？" class="headerlink" title="如何发请求？"></a>如何发请求？</h2><h6 id="用-form-可以发请求，但是会刷新页面或新开页面"><a href="#用-form-可以发请求，但是会刷新页面或新开页面" class="headerlink" title="用 form 可以发请求，但是会刷新页面或新开页面"></a>用 form 可以发请求，但是会刷新页面或新开页面</h6><h6 id="用-a-可以发-get-请求，但是也会刷新页面或新开页面"><a href="#用-a-可以发-get-请求，但是也会刷新页面或新开页面" class="headerlink" title="用 a 可以发 get 请求，但是也会刷新页面或新开页面"></a>用 a 可以发 get 请求，但是也会刷新页面或新开页面</h6><h6 id="用-img-可以发-get-请求，但是只能以图片的形式展示"><a href="#用-img-可以发-get-请求，但是只能以图片的形式展示" class="headerlink" title="用 img 可以发 get 请求，但是只能以图片的形式展示"></a>用 img 可以发 get 请求，但是只能以图片的形式展示</h6><h6 id="用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示"><a href="#用-link-可以发-get-请求，但是只能以-CSS、favicon-的形式展示" class="headerlink" title="用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示"></a>用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示</h6><h6 id="用-script-可以发-get-请求，但是只能以脚本的形式运行"><a href="#用-script-可以发-get-请求，但是只能以脚本的形式运行" class="headerlink" title="用 script 可以发 get 请求，但是只能以脚本的形式运行"></a>用 script 可以发 get 请求，但是只能以脚本的形式运行</h6><h2 id="有没有什么方式可以实现"><a href="#有没有什么方式可以实现" class="headerlink" title="有没有什么方式可以实现"></a>有没有什么方式可以实现</h2><ol>
<li>get、post、put、delete 请求都行</li>
<li>想以什么形式展示就以什么形式展示</li>
</ol>
<h2 id="微软的突破"><a href="#微软的突破" class="headerlink" title="微软的突破"></a>微软的突破</h2><h6 id="IE-5-率先在-JS-中引入-ActiveX-对象（API），使得-JS-可以直接发起-HTTP-请求。"><a href="#IE-5-率先在-JS-中引入-ActiveX-对象（API），使得-JS-可以直接发起-HTTP-请求。" class="headerlink" title="IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。"></a>IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。</h6><h6 id="随后-Mozilla、-Safari、-Opera-也跟进（抄袭）了，取名-XMLHttpRequest，并被纳入-W3C-规范"><a href="#随后-Mozilla、-Safari、-Opera-也跟进（抄袭）了，取名-XMLHttpRequest，并被纳入-W3C-规范" class="headerlink" title="随后 Mozilla、 Safari、 Opera 也跟进（抄袭）了，取名 XMLHttpRequest，并被纳入 W3C 规范"></a>随后 Mozilla、 Safari、 Opera 也跟进（抄袭）了，取名 XMLHttpRequest，并被纳入 W3C 规范</h6><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h6 id="Jesse-James-Garrett-讲如下技术取名叫做-AJAX：异步的-JavaScript-和-XML"><a href="#Jesse-James-Garrett-讲如下技术取名叫做-AJAX：异步的-JavaScript-和-XML" class="headerlink" title="Jesse James Garrett 讲如下技术取名叫做 AJAX：异步的 JavaScript 和 XML"></a>Jesse James Garrett 讲如下技术取名叫做 AJAX：异步的 JavaScript 和 XML</h6><ol>
<li>使用 XMLHttpRequest 发请求</li>
<li>服务器返回 XML 格式的字符串</li>
<li>JS 解析 XML，并更新局部页面</li>
</ol>
<p><img src="/2018/05/17/AJAX/a1.png" alt=""></p>
<h1 id="35高级：自己实现-AJAX"><a href="#35高级：自己实现-AJAX" class="headerlink" title="35高级：自己实现 AJAX"></a>35高级：自己实现 AJAX</h1><h4 id="添加ajax的内存图"><a href="#添加ajax的内存图" class="headerlink" title="添加ajax的内存图"></a>添加ajax的内存图</h4><p><img src="/2018/05/17/AJAX/a2.png" alt=""></p>
<h4 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h4><p><img src="/2018/05/17/AJAX/a3.png" alt=""><br><img src="/2018/05/17/AJAX/a4.png" alt=""><br><img src="/2018/05/17/AJAX/a5.png" alt=""><br><img src="/2018/05/17/AJAX/a6.png" alt=""></p>
<h4 id="响应与请求的设置顺序及方法"><a href="#响应与请求的设置顺序及方法" class="headerlink" title="响应与请求的设置顺序及方法"></a>响应与请求的设置顺序及方法</h4><p><img src="/2018/05/17/AJAX/a7.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/17/AJAX/" data-id="cjmqbc2qb00003hf4veuthfbf" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JSONP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/13/JSONP/" class="article-date">
  <time datetime="2018-05-13T09:15:05.000Z" itemprop="datePublished">2018-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/13/JSONP/">JSONP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="33高级：JSONP-是什么鬼"><a href="#33高级：JSONP-是什么鬼" class="headerlink" title="33高级：JSONP 是什么鬼"></a>33高级：JSONP 是什么鬼</h1><h3 id="JSONP的完整代码演变"><a href="#JSONP的完整代码演变" class="headerlink" title="JSONP的完整代码演变"></a>JSONP的<a href="https://github.com/yingzhongbin/XDML/tree/master/server" target="_blank" rel="noopener">完整代码演变</a></h3><p><img src="/2018/05/13/JSONP/p1.png" alt=""><br><img src="/2018/05/13/JSONP/p2.png" alt=""><br><img src="/2018/05/13/JSONP/p3.png" alt=""></p>
<h3 id="面试问题：请问，为什么JSONP不支持POST请求？"><a href="#面试问题：请问，为什么JSONP不支持POST请求？" class="headerlink" title="面试问题：请问，为什么JSONP不支持POST请求？"></a>面试问题：请问，为什么JSONP不支持POST请求？</h3><h4 id="因为JSONP是通过动态创建script实现的，我们动态创建script时只能用GET，不能用POST"><a href="#因为JSONP是通过动态创建script实现的，我们动态创建script时只能用GET，不能用POST" class="headerlink" title="因为JSONP是通过动态创建script实现的，我们动态创建script时只能用GET，不能用POST"></a>因为JSONP是通过动态创建script实现的，我们动态创建script时只能用GET，不能用POST</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/13/JSONP/" data-id="cjmqbc2qu00043hf4w2wdhbjg" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/01/CSS笔记-长期更新/">CSS笔记(长期更新)</a>
          </li>
        
          <li>
            <a href="/2018/09/28/flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释/">flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释</a>
          </li>
        
          <li>
            <a href="/2018/09/08/http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified/">http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified</a>
          </li>
        
          <li>
            <a href="/2018/08/11/路由/">路由</a>
          </li>
        
          <li>
            <a href="/2018/08/08/Vue的三种通信方法/">Vue的三种通信方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 应忠彬<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>