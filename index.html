<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>应忠彬的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="应忠彬的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="应忠彬的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="应忠彬的博客">
  
    <link rel="alternate" href="/atom.xml" title="应忠彬的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">应忠彬的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Web性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/16/Web性能优化/" class="article-date">
  <time datetime="2018-10-16T09:37:41.000Z" itemprop="datePublished">2018-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/16/Web性能优化/">Web性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Web性能优化的目的：让网站加载更快。所以如何优化Web性能可以从请求网页过程来进行思考。"><a href="#Web性能优化的目的：让网站加载更快。所以如何优化Web性能可以从请求网页过程来进行思考。" class="headerlink" title="Web性能优化的目的：让网站加载更快。所以如何优化Web性能可以从请求网页过程来进行思考。"></a>Web性能优化的目的：让网站加载更快。所以如何优化Web性能可以从请求网页过程来进行思考。</h4><p>以下列举格式为：请求网页过程[优化措施]<br>1.缓存[有缓存，直接从缓存读取]<br>2.DNS查询 [减少DNS查询，即减少域名，把文件放在一个网站上]<br>3.建立TCP链接  [使用连接复用，请求头上添加keep-alive。 使用hTTP/2.0的多路复用]<br>4.发送HTTP请求  [1.ETag，通过后台处理。2.请求头第二部分减少cookie体积。3.使用cache-control，不发送请求。4.同时发多个请求，请求CSS和JS，提高效率。需要增加域名，提高下载速度。做到测试和权衡。(如果文件少，放一个域名，文件多，放多个域名里，接近下载限制以加快速度。5.CDN没有Cookie)]<br>5.接收响应[1.使用ETag接收消息304，使用上次的文件2.使用gzip压缩]<br>6.接收完成–&gt;HTML[回车注释删掉]<br>7.检查DOCTYPE类型进行解析[不要写错，不能不写]<br>8.逐行解析[  </p>
<ul>
<li>看到标签\&lt;h1>[减少标签]<ul>
<li>在页面显示标题</li>
<li>不在页面显示标题（chrome不渲染）</li>
</ul>
</li>
<li>看到CSS<ul>
<li>下载CSS</li>
<li>继续往下看还有没有CSS</li>
<li>下载CSS2<br> 同时下载CSS。都下载完毕后再解析CSS（下载并行，解析串行）<br>（chrome中CSS会阻塞HTML渲染）<br>]  </li>
</ul>
</li>
</ul>
<p>9.看到JS，也是下载并行，解析串行。CSS一定会阻塞HTML渲染。JS没下载完，后面的标签不会渲染。</p>
<h2 id="其他优化思考"><a href="#其他优化思考" class="headerlink" title="其他优化思考"></a>其他优化思考</h2><hr>
<p>CSS、JS的优化：  </p>
<ul>
<li>1.放到CDN上（不同域名的文件能同时下载）<br>CDN：使用CDN(内容分发网络)</li>
<li><p>2.css放到head，js放body最后（提早下载CSS，没有js用户也能看到页面，js放后面能获取到节点）</p>
<h2 id="其他优化-总结自雅虎前端优化35条规则"><a href="#其他优化-总结自雅虎前端优化35条规则" class="headerlink" title="其他优化(总结自雅虎前端优化35条规则)"></a>其他优化(总结自<a href="https://github.com/creeperyang/blog/issues/1" target="_blank" rel="noopener">雅虎前端优化35条规则</a>)</h2><p>1.减少请求数[合并文件]<br>2.延迟加载[所有不必须的文件都进行懒加载，设置定时器(大公司用，淘宝)，可加loading动画]<br>3.预加载<br>4.避免空src的图片[src=’about:blank’]<br>5.单独将CSS、JS放置在一个文件里。便于缓存<br>6.压缩JS和CSS<br>7.优化图片<br>8.使用事件委托  </p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/16/Web性能优化/" data-id="cjnco4o140006gjf4ge0dypmi" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS模拟继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/15/JS模拟继承/" class="article-date">
  <time datetime="2018-10-15T08:46:02.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/JS模拟继承/">JS模拟继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js中并没有真正的class概念，它有的概念就是原型链。通过原型链实现类的继承。构造函数（即类）的prototype属性只有一个功能，存储共有属性对象的地址。通过子类与父类的<strong>prpto</strong>的链接，实现所谓的继承。</p>
<h4 id="对象和构造函数是如何实现求取共同数据的呢？"><a href="#对象和构造函数是如何实现求取共同数据的呢？" class="headerlink" title="对象和构造函数是如何实现求取共同数据的呢？"></a>对象和构造函数是如何实现求取共同数据的呢？</h4><p>构造函数使用protpotype，对象使用<strong>proto</strong>。JS设定它们相等，实现共同数据的绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Man()&#123;&#125;</span><br><span class="line">var a = new Man()</span><br><span class="line">a.__proto__ === Man.prototype // true</span><br></pre></td></tr></table></figure></p>
<h4 id="ES-5是如何实现继承的呢？"><a href="#ES-5是如何实现继承的呢？" class="headerlink" title="ES 5是如何实现继承的呢？"></a>ES 5是如何实现继承的呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Human(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 通过在父类的prototype上绑定数据实现父类共同属性的设定</span><br><span class="line">Human.prototype.run = function()&#123;</span><br><span class="line">    console.log(this.name+&apos; is running&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function Man(name)&#123;</span><br><span class="line">    Human.call(this,name) //通过call将父类的赋值移到子类上</span><br><span class="line">    this.gender = &apos;man&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 链接父类和子类</span><br><span class="line">//Man.prototype.__proto__ = Human.prototype</span><br><span class="line">// =</span><br><span class="line">//链接父类和子类的另一种写法，兼容IE。这种写法需要后设定子类的prototype</span><br><span class="line">var f = function()&#123;&#125;</span><br><span class="line">f.prototype = Human.prototype</span><br><span class="line">Man.prototype = new f()</span><br><span class="line"></span><br><span class="line">// 通过在子类的prototype上绑定数据实现子类共同属性的设定</span><br><span class="line">Man.prototype.fight = function()&#123;</span><br><span class="line">    console.log(this.name+&apos; is fighting&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var man = new Man(&apos;ff&apos;)</span><br><span class="line">man</span><br></pre></td></tr></table></figure>
<p>数据结构如下：<br><img src="https://i.loli.net/2018/10/16/5bc5adad1320f.png" alt=""></p>
<h4 id="ES-6的继承写法"><a href="#ES-6的继承写法" class="headerlink" title="ES 6的继承写法"></a>ES 6的继承写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Human&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.属性 = &apos;attrs&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设定属性</span><br><span class="line">    get species()&#123;</span><br><span class="line">        return &apos;human&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(this.name+&apos; is running&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Man extends Human&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        super(name)</span><br><span class="line">        this.gender = &apos;man&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    fight()&#123;</span><br><span class="line">        console.log(this.name+&apos; is fighting&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var man = new Man(&apos;ff&apos;)</span><br><span class="line">man</span><br></pre></td></tr></table></figure>
<p>数据结构如下：<br><img src="https://i.loli.net/2018/10/16/5bc5adad39ceb.png" alt=""></p>
<p>ES 5 和 ES 6的继承方法比较：<br>ES5的写法比较繁琐，如果没有对原型链的深刻理解，难以自己写出继承。ES6的继承写法已经被加上了语法糖，不懂原型链也能轻松写出继承。ES5对原型的操作会让浏览器开销较大，是它的缺点。 建议ES 5的继承作为练习为佳，ES 6的继承更适合实际编程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/15/JS模拟继承/" data-id="cjnco4o1a0007gjf46urjakak" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-你真的懂函数吗？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/13/你真的懂函数吗？/" class="article-date">
  <time datetime="2018-10-13T03:14:52.000Z" itemprop="datePublished">2018-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/13/你真的懂函数吗？/">你真的懂函数吗？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fn = function()&#123;</span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line">var fn2 = fn</span><br><span class="line">fn.name // fn</span><br><span class="line">fn2.name // fn</span><br></pre></td></tr></table></figure>
<p>点评：fn和fn2存的都是这个匿名函数的地址！</p>
<h2 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn3()&#123;</span><br><span class="line">    return 3</span><br><span class="line">&#125;</span><br><span class="line">var fn5 = function fn4()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(fn3)</span><br><span class="line">console.log(fn4)//报错</span><br></pre></td></tr></table></figure>
<p>点评：fn4只能在function内使用，在全局作用域中不可使用</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fn6 = e=&gt;e+1</span><br><span class="line">fn6(6)</span><br><span class="line">var fn7 = (i,j)=&gt;i+j</span><br><span class="line">fn7(1,2)</span><br><span class="line">var fn8 = (i,j)=&gt;&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    return i+j</span><br><span class="line">&#125;</span><br><span class="line">fn8(5,6)</span><br></pre></td></tr></table></figure>
<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var global1 = 1</span><br><span class="line">function fn1(param1)&#123;</span><br><span class="line">    var local1 = &apos;local1&apos;</span><br><span class="line">    var local2 = &apos;local2&apos;)</span><br><span class="line">    function fn2(param2)&#123;</span><br><span class="line">        var local2 = &apos;inner local2&apos;</span><br><span class="line">        console.log(local1)</span><br><span class="line">        console.log(local2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fn3()&#123;</span><br><span class="line">        var local2 = &apos;fn3 local2&apos;</span><br><span class="line">        fn2(local2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/10/13/5bc19ccfde068.jpg" alt="test_1.jpg"><br>总结：函数只有在自身作用域中无法找到变量时，才会在上级作用域中去寻找。</p>
<p>拓展阅读：<br><a href="https://js8.in/2011/08/15/javascript%E7%9A%84%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/" target="_blank" rel="noopener">javascript的词法作用域</a></p>
<h3 id="call-stack（堆栈调用-已会）"><a href="#call-stack（堆栈调用-已会）" class="headerlink" title="call stack（堆栈调用,已会）"></a>call stack（堆栈调用,已会）</h3><h2 id="this-amp-arguments"><a href="#this-amp-arguments" class="headerlink" title="this &amp; arguments"></a>this &amp; arguments</h2><p>重要：this 就是 call 的第一个参数！call 的其他参数统称为 arguments<br>this 是隐藏的第一个参数，且必须是对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">f.call() // window</span><br><span class="line">f.call(&#123;name:&apos;frank&apos;&#125;) // &#123;name: &apos;frank&apos;&#125;, []</span><br><span class="line">f.call(&#123;name:&apos;frank&apos;&#125;,1) // &#123;name: &apos;frank&apos;&#125;, [1]</span><br><span class="line">f.call(&#123;name:&apos;frank&apos;&#125;,1,2) // &#123;name: &apos;frank&apos;&#125;, [1,2]</span><br></pre></td></tr></table></figure></p>
<p>this 为什么必须是对象<br>因为 this 就是函数与对象之间的羁绊<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;frank&apos;,</span><br><span class="line">    sayHi: function(person)&#123;</span><br><span class="line">        console.log(&apos;Hi, I am&apos; + person.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    sayBye: function(person)&#123;</span><br><span class="line">        console.log(&apos;Bye, I am&apos; + person.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    say: function(person, word)&#123;</span><br><span class="line">        console.log(word + &apos;, I am&apos; + person.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHi(person)</span><br><span class="line">person.sayBye(person)</span><br><span class="line">person.say(person, &apos;How are you&apos;)</span><br><span class="line"></span><br><span class="line">// 能不能变成 </span><br><span class="line">person.sayHi()</span><br><span class="line">person.sayBye()</span><br><span class="line">person.say(&apos;How are you&apos;)</span><br><span class="line"></span><br><span class="line">// 那么源代码就要改了</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;frank&apos;,</span><br><span class="line">    sayHi: function()&#123;</span><br><span class="line">        console.log(&apos;Hi, I am&apos; + this.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    sayBye: function()&#123;</span><br><span class="line">        console.log(&apos;Bye, I am&apos; + this.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    say: function(word)&#123;</span><br><span class="line">        console.log(word + &apos;, I am&apos; + this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果你不想吃语法糖</span><br><span class="line">person.sayHi.call(person)</span><br><span class="line">person.sayBye.call(person)</span><br><span class="line">person.say.call(person, &apos;How are you&apos;)</span><br><span class="line"></span><br><span class="line">// 还是回到那句话：this 是 call 的第一个参数</span><br><span class="line">// this 是参数，所以，只有在调用的时候才能确定</span><br><span class="line">person.sayHi.call(&#123;name:&apos;haha&apos;&#125;)  // 这时 sayHi 里面的 this 就不是 person 了</span><br><span class="line">// this 真的很不靠谱</span><br><span class="line"></span><br><span class="line">// 新手疑惑的两种写法</span><br><span class="line">var fn = person.sayHi</span><br><span class="line">person.sayHi() // this === person</span><br><span class="line">fn()  // this === window</span><br></pre></td></tr></table></figure></p>
<p>call / apply<br>fn.call(asThis, p1,p2) 是函数的正常调用方式<br>当你不确定参数的个数时，就使用 apply<br>fn.apply(asThis, params)  </p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind  "></a>bind  </h2><p>call 和 apply 是直接调用函数，而 bind 则是返回一个新函数（并没有调用原来的函数），这个新函数会 call 原来的函数，call 的参数由你指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name:&apos;yzb&apos;,</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    console.log(this.name)</span><br><span class="line">    function sayAgain()&#123;</span><br><span class="line">       console.log(1)</span><br><span class="line">       console.log(this)</span><br><span class="line">       console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">    sayAgain()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">person.sayName()</span><br><span class="line">&#123;name: &quot;yzb&quot;, sayName: ƒ&#125;</span><br><span class="line">yzb</span><br><span class="line">1</span><br><span class="line">window</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="bind-1"><a href="#bind-1" class="headerlink" title="bind"></a>bind</h2><p>call 和 apply 是直接调用函数，而 bind 则是返回一个新函数（并没有调用原来的函数），这个新函数会 call 原来的函数，call 的参数由你指定。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化：将 f(x,y) 变成 f(x=1)(y) 或 f(y=1)x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum(x,y)&#123;</span><br><span class="line">	return x+y</span><br><span class="line">&#125;</span><br><span class="line">function addOne(y)&#123;</span><br><span class="line">    return sum (1,y)</span><br><span class="line">&#125;</span><br><span class="line">addOne(4)</span><br><span class="line">function addTwo(y)&#123;</span><br><span class="line">    return sum(2,y)</span><br><span class="line">&#125;</span><br><span class="line">addTwo(4)</span><br></pre></td></tr></table></figure></p>
<p>应用于模板引擎，用来进行惰性求值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function templateHandler(template,data)&#123;</span><br><span class="line">    return template.replace(&apos;&#123;&#123;name&#125;&#125;&apos;,data.name)</span><br><span class="line">&#125;</span><br><span class="line">templateHandler(&apos;&lt;h1&gt;I am &#123;&#123;name&#125;&#125;!&lt;/h1&gt;&apos;,&#123;name:&apos;tom&apos;&#125;)</span><br><span class="line">function templatehandler2(template)&#123;</span><br><span class="line">    return function(data)&#123;</span><br><span class="line">        return template.replace(&apos;&#123;&#123;name&#125;&#125;&apos;,data.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = templatehandler2(&apos;&lt;h1&gt;I am &#123;&#123;name&#125;&#125;!&lt;/h1&gt;&apos;)</span><br><span class="line">f(&#123;name:&apos;fuck&apos;&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="高阶函数："><a href="#高阶函数：" class="headerlink" title="高阶函数："></a>高阶函数：</h2><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：</p>
<ul>
<li><p>1.接受一个或多个函数作为输入：<br>array.forEach.call(array,fn)<br>array.sort.call(array,fn)<br>array.map.call(array,fn)<br>array.filter.call(array,fn)<br>array.reduce.call(array,fn)</p>
</li>
<li><p>2.输出一个函数：</p>
</li>
<li><p>3.不过它也可以同时满足两个条件：<br><code>Function.prototype.bind
fn.bind.call(fn,{},1,2,3)</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let array = [1,2,3,4,5,6,7,8]</span><br><span class="line">let arr = array.filter(function(n)&#123;</span><br><span class="line">    return n%2 === 0</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr)</span><br><span class="line">//[2, 4, 6, 8]</span><br><span class="line">array.reduce(function(s,c)&#123;</span><br><span class="line">	return s+c</span><br><span class="line">&#125;)</span><br><span class="line">//36</span><br><span class="line"></span><br><span class="line">// 计算数组中的偶数的总和</span><br><span class="line">array.filter(function(n)&#123;</span><br><span class="line">    return n%2 === 0</span><br><span class="line">&#125;).reduce(function(s,c)&#123;</span><br><span class="line">	return s+c</span><br><span class="line">&#125;)</span><br><span class="line">等价于</span><br><span class="line">[].reduce.call(array.filter.call(array,function(n)&#123;</span><br><span class="line">    return n%2 === 0</span><br><span class="line">&#125;),function(s,c)&#123;</span><br><span class="line">	return s+c</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//奇数求和</span><br><span class="line">let array1 = [11,2,13,4,5,6,7]</span><br><span class="line">array1.filter(function(n)&#123;</span><br><span class="line">    return n%2 === 1</span><br><span class="line">&#125;).sort(function(a,b)&#123;</span><br><span class="line">    return a-b</span><br><span class="line">&#125;)</span><br><span class="line">[].sort.call(array1.filter.call(array1,function(n)&#123;</span><br><span class="line">    return n%2 === 1</span><br><span class="line">&#125;),function(a,b)&#123;</span><br><span class="line">    return a-b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>名词形式：被当做参数的函数就是回调<br>动词形式：调用这个回调<br>注意回调跟异步没有任何关系  </p>
<p>有关系的举例如下：<br>setTimeout(fn,1000)<br>function fn(){<br>    console.log(this.name)<br>}<br>let obj = {<br>    name:’jack’<br>}<br>setTimeout(fn.bind(obj),1000)</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>返回对象的函数就是构造函数<br>一般首字母大写<br><a href="https://zhuanlan.zhihu.com/p/23987456" target="_blank" rel="noopener">JS 的 new 到底是干什么的？</a></p>
<h2 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fn = ()=&gt;&#123;console.log(this)&#125;</span><br><span class="line">fn.bind(&#123;name:&apos;jack&apos;&#125;)</span><br><span class="line">fn()</span><br><span class="line">// window</span><br></pre></td></tr></table></figure>
<p>箭头函数就不接收this</p>
<p>function curry(func,argu){<br>    console.log(argu)<br>    return function(){<br>    }<br>}<br>var abc = function(a, b, c) {<br>  return [a, b, c];<br>};</p>
<p>var curried = curry(abc);</p>
<p>curried(1)(2)(3);<br>// =&gt; [1, 2, 3]</p>
<p>curried(1, 2)(3);<br>// =&gt; [1, 2, 3]</p>
<p>curried(1, 2, 3);<br>// =&gt; [1, 2, 3]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/13/你真的懂函数吗？/" data-id="cjnco4o3q000ngjf4chzzkv69" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TypeScript学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/09/TypeScript学习笔记/" class="article-date">
  <time datetime="2018-10-09T11:38:34.000Z" itemprop="datePublished">2018-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="tsc"><a href="#tsc" class="headerlink" title="tsc "></a>tsc </h2><p>TypeScript compiler</p>
<h2 id="如何翻译为js文件？"><a href="#如何翻译为js文件？" class="headerlink" title="如何翻译为js文件？"></a>如何翻译为js文件？</h2><p>tsc xx.ts</p>
<h2 id="string类型验证："><a href="#string类型验证：" class="headerlink" title="string类型验证： "></a>string类型验证： </h2><p>undefined也可以通过 </p>
<h2 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h2><p>interface XX{</p>
<p>}<br>接口设置的类型可以作为验证类型</p>
<h2 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(a:numbPer,b:number):number;</span><br><span class="line">function add(a:string,b:string):string;</span><br><span class="line">function add(a:string,b:number):string;</span><br><span class="line">function add(a:any,b:any):any&#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1,2))</span><br><span class="line">console.log(add(&apos;11111&apos;,&apos;22222&apos;))</span><br><span class="line">console.log(add(&apos;11111&apos;,2222))</span><br></pre></td></tr></table></figure>
<p><code>function add(a:any,b:any):any</code>必须要加，表示兼容上述所有验证方法</p>
<h2 id="数组验证"><a href="#数组验证" class="headerlink" title="数组验证"></a>数组验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function select(a:number[]):number[]&#123;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在class里的参数加上public，表示声明，可用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    fullName: string;</span><br><span class="line">    constructor(public firstName: string, public lastName: string) &#123;</span><br><span class="line">        this.fullName = firstName + &quot; &quot; + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制返回值的验证<br><code>function min(a:number,b:number):number{}</code></p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string和number类型的元组。</span><br><span class="line">// Declare a tuple type</span><br><span class="line">let x: [string, number];</span><br><span class="line">// Initialize it</span><br><span class="line">x = [&apos;hello&apos;, 10]; // OK</span><br><span class="line">// Initialize it incorrectly</span><br><span class="line">x = [10, &apos;hello&apos;]; // Error</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//枚举</span><br><span class="line">enum Gender &#123;</span><br><span class="line">    male = &apos;男&apos;,</span><br><span class="line">    female = &apos;女&apos;</span><br><span class="line">&#125;</span><br><span class="line">interface Person&#123;</span><br><span class="line">    gender:Gender</span><br><span class="line">&#125;</span><br><span class="line">//元组</span><br><span class="line">function marry(a:Person,b:Person):[Person,Person]&#123;</span><br><span class="line">    if(a.gender !== b.gender)&#123;</span><br><span class="line">        return [a,b]</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw new Error(&quot;不接受同性结婚&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = &#123;gender:Gender.male&#125;</span><br><span class="line">let b = &#123;gender:Gender.female&#125;</span><br><span class="line">console.log(marry(a,b))</span><br></pre></td></tr></table></figure>
<h2 id="执行命令行程序，添加shebang"><a href="#执行命令行程序，添加shebang" class="headerlink" title="执行命令行程序，添加shebang"></a>执行命令行程序，添加shebang</h2><p><code>#!/usr/bin/env ts-node</code></p>
<h2 id="添加ts文件执行权限"><a href="#添加ts文件执行权限" class="headerlink" title="添加ts文件执行权限"></a>添加ts文件执行权限</h2><p>chmod +x 1.ts</p>
<h2 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h2><p>./1.ts</p>
<h2 id="创建package-json"><a href="#创建package-json" class="headerlink" title="创建package.json"></a>创建package.json</h2><p>npm init -y</p>
<h2 id="error-TS2339-Property-‘isNaN’-does-not-exist-on-type-‘NumberConstructor’"><a href="#error-TS2339-Property-‘isNaN’-does-not-exist-on-type-‘NumberConstructor’" class="headerlink" title=" error TS2339: Property ‘isNaN’ does not exist on type ‘NumberConstructor’"></a> error TS2339: Property ‘isNaN’ does not exist on type ‘NumberConstructor’</h2><p> 添加文件 tsconfig.json<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;lib&quot;: [</span><br><span class="line">            &quot;es2015&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="String-literal-with-double-quotes-expected"><a href="#String-literal-with-double-quotes-expected" class="headerlink" title="String literal with double quotes expected."></a>String literal with double quotes expected.</h2><p>json中只能使用双引号</p>
<h2 id="程序退出"><a href="#程序退出" class="headerlink" title="程序退出"></a>程序退出</h2><p>process.exit(0)</p>
<h2 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值"></a>无返回值</h2><p>:void</p>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>n?:number</p>
<h2 id="多类型"><a href="#多类型" class="headerlink" title="多类型"></a>多类型</h2><p>:(string|person)</p>
<h2 id="代码简化"><a href="#代码简化" class="headerlink" title="代码简化"></a>代码简化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(!n)&#123;n = 1&#125;</span><br><span class="line">//to</span><br><span class="line">n = n || 1</span><br></pre></td></tr></table></figure>
<h2 id="js-string-API"><a href="#js-string-API" class="headerlink" title="js string API"></a>js string API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * str: String</span><br><span class="line"> * count: Number</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">let resultString = str.repeat(count);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/09/TypeScript学习笔记/" data-id="cjnco4o1m0009gjf477dyuyvb" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/06/ES6/" class="article-date">
  <time datetime="2018-10-06T11:33:47.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/06/ES6/">ES6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>1.let 的作用域在最近的{}之间<br>2.如果你在let a 之前使用a，那么报错<br>3.如果你重复声明let a，那么报错</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>1.2.3. 同上<br>4.只有一次赋值机会，而且必须声明的时候立马赋值</p>
<p>for(let i = 0;i&lt;6;i++){  // 这里的i的作用域只在（）里<br>    // js自动加了： {}里的i =（）里的i   这么一个处理<br>    liTags[i].onclick = function(){<br>        console.log(i)<br>    }<br>}</p>
<p>共7个i</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/06/ES6/" data-id="cjnco4o0t0004gjf46hm3iv7d" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/06/vue学习笔记/" class="article-date">
  <time datetime="2018-10-06T08:56:57.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/06/vue学习笔记/">vue学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="vue中this-scopedSlots-default的demo"><a href="#vue中this-scopedSlots-default的demo" class="headerlink" title="vue中this.$scopedSlots.default的demo"></a>vue中this.$scopedSlots.default的demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;base-component :message=&quot;message&quot;&gt;</span><br><span class="line">        &lt;template slot-scope=&quot;props&quot;&gt; &#123;&#123;props.fuck&#125;&#125;&lt;/template&gt;</span><br><span class="line">    &lt;/base-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&apos;BaseComponent&apos;, &#123;</span><br><span class="line">        props: [&apos;message&apos;], /*template: `</span><br><span class="line">      &lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span><br><span class="line">     `,*/</span><br><span class="line">        render: function (createElement) &#123;</span><br><span class="line">            console.log(this)</span><br><span class="line">            return createElement(&apos;div&apos;, [&apos;&lt;div&gt;第一个子节点&lt;/div&gt;&apos;, this.$scopedSlots.default(&#123;fuck: this.message&#125;)])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &apos;#box&apos;, data() &#123;</span><br><span class="line">            return &#123;&apos;message&apos;: &apos;Hi&apos;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/06/vue学习笔记/" data-id="cjnco4o3r000ogjf4r5vxruy5" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CSS笔记-长期更新" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/01/CSS笔记-长期更新/" class="article-date">
  <time datetime="2018-10-01T12:29:49.000Z" itemprop="datePublished">2018-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/01/CSS笔记-长期更新/">CSS笔记(长期更新)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="CSS-white-space-属性"><a href="#CSS-white-space-属性" class="headerlink" title="CSS white-space 属性"></a>CSS white-space 属性</h4><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>white-space</td>
<td>属性设置如何处理元素内的空白</td>
</tr>
<tr>
<td>normal</td>
<td>默认。空白会被浏览器忽略。</td>
</tr>
<tr>
<td>pre</td>
<td>空白会被浏览器保留。其行为方式类似 HTML 中的 <code>&lt;pre&gt;</code> 标签。</td>
</tr>
<tr>
<td>nowrap</td>
<td>文本不会换行，文本会在在同一行上继续，直到遇到 <code>&lt;br&gt;</code>标签为止。</td>
</tr>
<tr>
<td>pre-wrap</td>
<td>保留空白符序列，但是正常地进行换行。</td>
</tr>
<tr>
<td>pre-line</td>
<td>合并空白符序列，但是保留换行符。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 white-space 属性的值。</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/01/CSS笔记-长期更新/" data-id="cjnco4o0i0002gjf4k7949w6n" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释/" class="article-date">
  <time datetime="2018-09-28T12:17:42.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释/">flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="文字超过部分显示为省略号的css写法很简单"><a href="#文字超过部分显示为省略号的css写法很简单" class="headerlink" title="文字超过部分显示为省略号的css写法很简单"></a>文字超过部分显示为省略号的css写法很简单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	text-overflow: ellipsis;</span><br><span class="line">  	overflow: hidden;</span><br><span class="line"> 	white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是：可以不加宽度<code>width:xxx;</code>，也不用加min-width。这时， 文字超过部分会乖乖地显示为省略号。</p>
<p>在flex布局下，当flex-grow设置为1（即自由伸缩）的情况下，是不需要设置宽度，内容就会自动生长。没有宽度设定，在flex布局下flex-grow部分中，上述三行代码无法生效。它就像脱缰的野马一样，说：“你没有给我设定宽度啊，我grow了，不需要显示为省略号，略略略~~~。”</p>
<h6 id="那如何解决呢？"><a href="#那如何解决呢？" class="headerlink" title="那如何解决呢？"></a>那如何解决呢？</h6><p>只要设定一下<code>width:xxx;</code>，甚至可以设置为<code>width:0px;</code>。设置min-width不生效。<br>总之，flew-grow控制伸缩。而上述代码加宽度管超出省略。而flex-grow的优先级高于width，仍然可以伸缩。宽度设置只是做个样子，告诉内容你给我丫的显示为省略号！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/28/flex布局下flex-grow部分的文字超过部分显示为省略号的方法和解释/" data-id="cjnco4o2l000dgjf4ixhji5z5" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/08/http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified/" class="article-date">
  <time datetime="2018-09-08T07:54:04.000Z" itemprop="datePublished">2018-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified/">http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="笔记摘要"><a href="#笔记摘要" class="headerlink" title="笔记摘要"></a>笔记摘要</h3><p>cookie session cache-control都是响应头</p>
<h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><p>GET /xxx HTTP/1.1<br>Host:xxx.com</p>
<h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>HTTP/1.1 200 ok<br>Content-Type:text/html;charset=utf8<br>Content-Length:100b  </p>
<h6 id="js发送请求代码"><a href="#js发送请求代码" class="headerlink" title="js发送请求代码"></a>js发送请求代码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var request = new XMLHttpRequest()</span><br><span class="line">request.open(“POST”,’/xxx’)</span><br><span class="line">request.onreadystatechange = function()&#123;</span><br><span class="line">	if(request.readyState === 4 &amp;&amp; request.status ===200)&#123;</span><br><span class="line">		响应成功</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 发送请求</span><br><span class="line"> request.send(“a=1&amp;b=2”)</span><br></pre></td></tr></table></figure>
<p>cookie就是入门票  每来一次都要出示一次</p>
<h3 id="Cookie特点"><a href="#Cookie特点" class="headerlink" title="Cookie特点"></a>Cookie特点</h3><p>1.服务器通过Set-Cookie 响应头设置Cookie<br>2.浏览器得到Cookie之后，每次请求都要带上Cookie<br>3.服务器读取Cookie就知道登录用户的信息  </p>
<h6 id="Cookie相关问题"><a href="#Cookie相关问题" class="headerlink" title="Cookie相关问题"></a>Cookie相关问题</h6><p>1.我在Chrome登录了得到Cookie，用Safar访问，Safari会带上Cookie吗<br>NO  </p>
<p>2.Cookie存在哪？<br>存在系统的一个文件里 </p>
<p>3.Cookie能作假吗？<br>可以    </p>
<p>4.Cookie有有效期吗？<br>默认有效期20分钟左右,后端可以强制设置有效期  </p>
<h4 id="登录注册的Cookie设定过程"><a href="#登录注册的Cookie设定过程" class="headerlink" title="登录注册的Cookie设定过程"></a>登录注册的Cookie设定过程</h4><table>
<thead>
<tr>
<th>服务器</th>
<th>过程</th>
<th>用户</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>开始注册</td>
</tr>
<tr>
<td></td>
<td>&lt;==发送POST请求，数据为email,passpword,password_confirm</td>
<td></td>
</tr>
<tr>
<td>将数据email，passpword写入数据库</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>注册成功 ==&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>开始登录</td>
</tr>
<tr>
<td></td>
<td>&lt;==发送POST请求，数据为email,passpword</td>
<td></td>
</tr>
<tr>
<td>验证成功</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>SetCookie 数据为email ==&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>打开首页</td>
</tr>
<tr>
<td></td>
<td>&lt;==发送GET请求，会带上Cookie里的数据email</td>
<td></td>
</tr>
<tr>
<td>读取Cookie里的数据email，找到数据库里的用户信息，返回index.html,并将index.html里需要的用户信息替换掉</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>使用Cookie过程<br>1.Set-Cookie<br>2.每次请求相同域名时带上Cookie  </p>
<p>用途：<br>登录成功</p>
<p>电脑上设置了Cookie，每次访问首页时，会带上Cookie发送请求。<br>服务器读取Cookie。如果有信息，去数据库寻找用户信息返回。</p>
<p>Cookie有一个缺点，可以被篡改。所以就引入了session</p>
<p>什么是Session?<br>服务器通过Cookie给用户一个sessionId，sessionId对应服务器里的一小块内存。每次用户访问服务器时，服务器就通过sessionId读取对应的Session，得到用户的隐私信息。</p>
<p>Cookie  </p>
<ol>
<li>服务器通过 Set-Cookie 头给客户端一串字符串  </li>
<li>客户端每次访问相同域名的网页时，必须带上这段字符串  </li>
<li>客户端要在一段时间内保存这个Cookie  </li>
<li>Cookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间  </li>
<li>大小大概在 4kb 以内 </li>
</ol>
<p>Session（不翻译）  </p>
<ol>
<li>将 SessionID（随机数）通过 Cookie 发给客户端  </li>
<li>客户端访问服务器时，服务器读取 SessionID  </li>
<li>服务器有一块内存（哈希表）保存了所有 session  </li>
<li>通过 SessionID 我们可以得到对应用户的隐私信息，如 id、email  </li>
<li>这块内存（哈希表）就是服务器上的所有 session </li>
</ol>
<p>LocalStorage    </p>
<ol>
<li>LocalStorage 跟 HTTP 无关  </li>
<li>HTTP 不会带上 LocalStorage 的值  </li>
<li>只有相同域名的页面才能互相读取 LocalStorage（没有同源那么严格）  </li>
<li>每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）  </li>
<li>常用场景：记录有没有提示过用户（没有用的信息，不能记录密码）  </li>
<li>LocalStorage 永久有效，除非用户清理缓存  </li>
</ol>
<p>SessionStorage（会话存储）  </p>
<ol>
<li>1、2、3、4 同上    </li>
<li>5：SessionStorage 在用户关闭页面（会话结束）后就失效。</li>
</ol>
<p>localStorage是持久化存储，用户不清空，不会过期<br>localStorage是html5里的API</p>
<h6 id="localStorage-API"><a href="#localStorage-API" class="headerlink" title="localStorage API"></a>localStorage API</h6><p>localStorage.setItem(key,value)<br>localStorage.getItem(key)<br>localStorage.clear()  </p>
<h6 id="sessionStorage-API"><a href="#sessionStorage-API" class="headerlink" title="sessionStorage API"></a>sessionStorage API</h6><p>sessionStorage.setItem(key,value)<br>sessionStorage.getItem(key)<br>sessionStorage.removeItem(key)  </p>
<h6 id="Cookie-Session什么关系？"><a href="#Cookie-Session什么关系？" class="headerlink" title="Cookie Session什么关系？"></a>Cookie Session什么关系？</h6><p>Session是基于Cookie实现的<br>Cookie localStorage有什么区别？<br>Cookie会被发送给服务器，localStorage不会。<br>localStorage SessionStorage什么区别  </p>
<p>session 也可以通过查询参数和localStorage来设置</p>
<p>前端永远不要读、写Cookie</p>
<h6 id="缓存控制-Cache-Control，设置后用户可以直接从缓存中读取文件，不发起请求"><a href="#缓存控制-Cache-Control，设置后用户可以直接从缓存中读取文件，不发起请求" class="headerlink" title="缓存控制 Cache-Control，设置后用户可以直接从缓存中读取文件，不发起请求"></a>缓存控制 Cache-Control，设置后用户可以直接从缓存中读取文件，<em>不发起请求</em></h6><table>
<thead>
<tr>
<th>服务器</th>
<th>过程</th>
<th>用户</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>&lt;==发送请求，请求文件main.js</td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回main.js文件 以及响应头max-age:30 ==&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;==同样的url请求（没有发送请求）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>==&gt;从内存里读取上一次的main.js</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;==过了30秒，发送请求，请求文件main.js</td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回main.js文件 以及响应头max-age:30 ==&gt;</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>response.setHeader(“Cache-Control”,”max-age=30”)//30秒内不需要再次请求，内容直接从缓存里读取</code></p>
<p>首页不允许设置缓存。<br>只有相同的url才会利用上次的缓存，所以，如果文件更新了，设置一个查询参数就可以了。<br>href=“default.css?v=2”  </p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>从前使用 Expires<br>现在使用 Cache-Control<br><code>response.setHeader(“Expires”,”未来的格林威治时间点”)</code><br>它是与用户的本地时间进行对比的，如果用户本地时间错乱，那就有问题了。  </p>
<h3 id="ETag-直接不下载（有请求）"><a href="#ETag-直接不下载（有请求）" class="headerlink" title="ETag  直接不下载（有请求）"></a>ETag  直接不下载（有请求）</h3><p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。<br>http  304 Not Modified</p>
<p>node.js代码<br><code>`
let fileMd5 = md5(file)
response.setHeader(“ETag”,fileMd5)
if(request.headers[‘if-none-match’] === fileMd5){
    //没有响应体
    response.statusCode = 304
}else{
    response.write(file)
}
response.end()</code></p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</p>
<h6 id="Last-Modified格式类似这样："><a href="#Last-Modified格式类似这样：" class="headerlink" title="Last-Modified格式类似这样："></a>Last-Modified格式类似这样：</h6><p>Last-Modified : Fri , 12 May 2006 18:53:33 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过：<br>If-Modified-Since : Fri , 12 May 2006 18:53:33 GMT<br>如果服务器端的资源没有变化，则自动返回 HTTP 304（Not Changed.）状态码，内容为空，这样就节省了传输数据量。  </p>
<p>从资源更新原理来看Last-Modified和Etag基本是类似的，那为什么http协议中要搞2个标识呢？<br>Last-Modified存在的问题：<br>1、在集群服务器上各个服务器上的文件时间可能不同。<br>2、如果用旧文件覆盖新文件，因为时间更前，浏览器不会请求这个更旧的文件。<br>3、时间精度为s级，对文件修改精度有严格要求的场景不能满足  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/08/http之Cookie、Session、LocalStorage、Cache-Control、ETag、Last-Modified/" data-id="cjnco4o3g000hgjf4nlmzirnr" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-路由" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/11/路由/" class="article-date">
  <time datetime="2018-08-11T08:23:59.000Z" itemprop="datePublished">2018-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/11/路由/">路由</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1.什么是路由"></a>1.什么是路由</h1><pre><code>简单举例说明，假如我们有一台提供 Web 服务的服务器的网络地址是：10.0.0.1，而该 Web 服务又提供了三个可供用户访问的页面，其页面 URI 分别是：
http://10.0.0.1/  
http://10.0.0.1/about  
http://10.0.0.1/concat  
那么其路径就分别是 /，/about，/concat。  
当用户使用 http://10.0.0.1/about 来访问该页面时，Web 服务会接收到这个请求，然后会解析 URL 中的路径 /about。在 Web 服务的程序中，该路径对应着相应的处理逻辑，程序会把请求交给路径所对应的处理逻辑，这样就完成了一次「路由分发」，这个分发就是通过「路由」来完成的。  
以前路由都是后台做的，通过用户请求的url导航到具体的html页面，前端路由就是通过配置js文件，把这个工作拿到前端来做。  
简单的说，路由是根据不同的 url 地址展示不同的内容或页面。
</code></pre><p>#2.    路由的作用<br>    路由的作用就是通过对用户访问的路径进行判断，将其发送到对应的处理请求逻辑上。</p>
<p>#3.    Vue 如何实现路由及其相关代码<br>     Vue官网已经有关于路由（Router）的详细代码介绍。我将根据官网的代码介绍其实现原理。<br>首先，引入vue.js和vue的vue-router文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>html代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Hello App!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;router-link to=&quot;/tab1&quot;&gt;Go to tab1&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/tab2&quot;&gt;Go to tab2&lt;/router-link&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const tab1 = &#123; template: &apos;&lt;div&gt;content 1&lt;/div&gt;&apos; &#125;</span><br><span class="line">const tab2 = &#123; template: &apos;&lt;div&gt;content 2&lt;/div&gt;&apos; &#125;</span><br><span class="line"></span><br><span class="line">const routes = [</span><br><span class="line">    &#123; path: &apos;/tab1&apos;, component: tab1 &#125;,</span><br><span class="line">    &#123; path: &apos;/tab2&apos;, component: tab2 &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes // (缩写) 相当于 routes: routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">    router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<pre><code>总结：在HTML代码中，Vue Router 使用router-link 标签来进行路由导航。通过传入 `to` 属性指定链接。&lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签。路由匹配到的组件将渲染在router-view标签中。
在JS代码中，需要做如下几件事情：
1.定义 (路由) 组件
2.定义路由（将路由组件传入到路由中）
3. 创建 router 实例
4. 创建和挂载根实例
</code></pre><h1 id="4-Vue-Router的优缺点"><a href="#4-Vue-Router的优缺点" class="headerlink" title="4.Vue Router的优缺点"></a>4.Vue Router的优缺点</h1><pre><code>Vue Router并不涉及后端。在前端进行路由分发时，需要后端对相应的路径进行放宽处理。  
比如：http://127.0.0.1:8081/tab0中，tab0 只是一个标记，在分享时，服务器需要放松对该路径的响应，直接返回index.html。但Vue Router并不需要后端进行任何处理，这为优点。
举例：Vue Router的链接响应处理为&lt;a href=&quot;#/tab1&quot; class=&quot;router-link-exact-active router-link-active&quot;&gt;Go to tab1&lt;/a&gt;。实际上是根据hash的不同调动页面状态。如果页面中有其他锚点的话，原有页面状态就很容易丢失了。也即为缺点。如果有其他需求需要规避这个缺点，可以通过修改pathname来记录页面状态。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/11/路由/" data-id="cjnco4o3w000sgjf4ckkv57lp" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/16/Web性能优化/">Web性能优化</a>
          </li>
        
          <li>
            <a href="/2018/10/15/JS模拟继承/">JS模拟继承</a>
          </li>
        
          <li>
            <a href="/2018/10/13/你真的懂函数吗？/">你真的懂函数吗？</a>
          </li>
        
          <li>
            <a href="/2018/10/09/TypeScript学习笔记/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/10/06/ES6/">ES6</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 应忠彬<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>